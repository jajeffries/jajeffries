<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Recycling tests</title>
	
	
	<link rel="stylesheet" href="/blog/css/style.css">
	
	
</head>
<body>
	<header>
	==========<br>
	== <a href="https://jajeffries.com/blog/">Blog</a> ==<br>
	==========
	<div style="float: right;">Your blog subtitle goes here!</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/blog/posts/"><b>Posts</b></a>.
			
			<a href="/blog/categories/"><b>Categories</b></a>.
			
			<a href="/blog/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Recycling tests</h1>
			<b><time>30.06.2015 20:28</time></b>
		       
		           <a href="/tags/uncategorized">Uncategorized</a>
        	       

			<div>
				<p>A couple of people have asked me about recycling tests recently, so I thought I’d put down some thoughts and an example here. Recycling tests is where you reuse old tests rather than writing new ones. Seb Rose changes the first step of the TDD cycle to</p>
<blockquote>
<p>writing a failing test or make an existing test fail.</p>
</blockquote>
<p>However, I don’t like the wording of this because to me it suggests that you could change the code to get a failing test. Instead I prefer</p>
<blockquote>
<p>writing a failing test or change an existing test to fail.</p>
</blockquote>
<p><strong>An Example</strong> As usual I’ll be using the checkout kata. I&rsquo;ll probably skim over a few details here, but hopefully you can still follow the changes I&rsquo;ve made. Let’s imagine I’ve got my first test passing and I’ve refactored. [code] import unittest class Tests(unittest.TestCase): def test_basic_price(self): item_price = 30 checkout = Checkout(item_price) checkout.scan(&lsquo;A&rsquo;) self.assertEqual(30, checkout.total()) class Checkout(object): def __init__(self, item_price): self.item_price = item_price self.current_total = 0 def scan(self, item): self.current_total = self.item_price def total(self): return self.current_total if __name__ == &lsquo;__main__&rsquo;: unittest.main() [/code] Notice how our scan method at the moment just sets the current_total, rather than adding to it. Our current test doesn’t specify this, so lets change our test to force us to add to our total. [code] class Tests(unittest.TestCase): def test_basic_price(self): item_price = 30 checkout = Checkout(item_price) checkout.scan(&lsquo;A&rsquo;) checkout.scan(&lsquo;A&rsquo;) self.assertEqual(60, checkout.total()) [/code] Now, we have a failing test again without writing a new test. We’ve just changed our existing test so haven’t added duplication (and all sorts of <a href="http://silkandspinach.net/tag/connascence/">connascence</a>), but we still have the same test coverage. Let&rsquo;s make our test pass. [code] class Checkout(object): def __init__(self, item_price): self.item_price = item_price self.current_total = 0 def scan(self, item): self.current_total += self.item_price def total(self): return self.current_total [/code] We can change our test for our next requirement too: scanning multiple types of item. [code] class Tests(unittest.TestCase): def test_basic_price(self): price_of_a = 30 price_of_b = 50 checkout = Checkout(price_of_a, price_of_b) checkout.scan(&lsquo;A&rsquo;) checkout.scan(&lsquo;B&rsquo;) self.assertEqual(price_of_a + price_of_b, checkout.total()) [/code] Again, we&rsquo;ve not added any new tests, but have changed our old test to fail. Now for the code. [code] class Checkout(object): def __init__(self, price_of_a, price_of_b): self.price_of_a = price_of_a self.price_of_b = price_of_b self.current_total = 0 def scan(self, item): if item == &lsquo;A&rsquo;: self.current_total += self.price_of_a else: self.current_total += self.price_of_b def total(self): return self.current_total [/code] <strong>Review</strong> There are a definite advantages to recycling tests. In our example, we have significantly less tests and as a result much less duplication. However, I can also see a potential problem. It would be possible (especially in a more complicated example) for regressions to be introduced, which wouldn&rsquo;t be caught by our test safety net. To avoid this we can be more careful with how we change our tests to fail. For example, recall when we added the second item type in our previous example. Our test looked like this: [code] class Tests(unittest.TestCase): def test_basic_price(self): price_of_a = 30 price_of_b = 50 checkout = Checkout(price_of_a, price_of_b) checkout.scan(&lsquo;A&rsquo;) checkout.scan(&lsquo;B&rsquo;) self.assertEqual(price_of_a + price_of_b, checkout.total()) [/code] Instead of changing the second scan to scan a &lsquo;B&rsquo;, we could add scanning &lsquo;B&rsquo; after scanning two &lsquo;A&rsquo;s. [code] class Tests(unittest.TestCase): def test_basic_price(self): price_of_a = 30 price_of_b = 50 checkout = Checkout(price_of_a, price_of_b) checkout.scan(&lsquo;A&rsquo;) checkout.scan(&lsquo;A&rsquo;) checkout.scan(&lsquo;B&rsquo;) self.assertEqual(price_of_a + price_of_a + price_of_b, checkout.total()) [/code] Now we have similar coverage as we would with two tests, but at the expense of a slightly more complicated test. I&rsquo;d be interested to know if other people have come across this problem, or if they think I&rsquo;m being over cautious. If you have any thoughts on any of this drop me a <a href="https://twitter.com/jjeffries1">tweet at @jjeffries1</a> ;-)</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/blog/pages/about-me/">About me</a></li>
				
				<li><a href="/blog/pages/talks/">Talks</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2024 <a href="https://jajeffries.com/blog/"><b>Blog</b></a>.
	<a href="https://github.com/example"><b>Github</b></a>.
	<a href="https://example.com/@user"><b>Mastodon</b></a>.
	<a href="/blog/imprint"><b>Imprint</b></a>.
	</p>
</footer>

</body>
</html>
