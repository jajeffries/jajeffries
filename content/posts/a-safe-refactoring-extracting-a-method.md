---
title: 'A safe refactoring: extracting a method'
date: Tue, 12 May 2015 12:08:24 +0000
draft: false
tags: []
---

Sometimes you have some code that is duplicated in multiple places. One approach to getting rid of this would be to extract it into a method. In this article I'll show you two different approaches you can take to do this and when I would use each one. **Setting the scene** I'm going to use the example of some tests for the [checkout kata](http://codekata.com/kata/kata09-back-to-the-checkout/). Let's say we've reached the following code \[code\] class CheckoutTests < Test::Unit::TestCase def test\_scanning\_one\_a prices = {'A':50, 'B': 70} checkout = Checkout.new(prices) checkout.scan('A') assert\_equal(50, checkout.total) end def test\_scanning\_multiple\_items prices = {'A':50, 'B': 70} checkout = Checkout.new(prices) checkout.scan('A') checkout.scan('B') assert\_equal(120, checkout.total) end end \[/code\] We have some duplication in the code where we set up our Checkout. \[code\] prices = {'A':50, 'B': 70} checkout = Checkout.new(prices) \[/code\] **Basic method extraction** So let's start off by adding a method which returns our Checkout. This is basically [Martin Fowler's Extract Method refactoring](http://refactoring.com/catalog/extractMethod.html). We'll just do this in one of the tests to start off with to make sure we aren't making to big a change in one go. \[code\] def new\_checkout prices = {'A':50, 'B': 70} Checkout.new(prices) end def test\_scanning\_one\_a checkout = new\_checkout checkout.scan('A') assert\_equal(50, checkout.total) end \[/code\] For me this feels like quite a jump so lets take a step back and see if we can break this down into a smaller step. We can use (or abuse) the fact that you can call a method in ruby without brackets to our advantage here. If we first assign our checkout to a variable called \[code\]new\_checkout\[/code\]. \[code\] def test\_scanning\_one\_a prices = {'A':50, 'B':70} new\_checkout = Checkout.new(prices) checkout = new\_checkout checkout.scan('A') assert\_equal(50, checkout.total) end \[/code\] Then we can move out the instantiation of our checkout into a method called \[code\]new\_checkout\[/code\]. \[code\] def new\_checkout prices = {'A':50, 'B':70} Checkout.new(prices) end def test\_scanning\_one\_a checkout = new\_checkout checkout.scan('A') assert\_equal(50, checkout.total) end \[/code\] This is only a slightly smaller step, but as we are running our tests after each change it can give us more confidence that what we are doing is working, and if it's not then we can press undo (or git stash) and try the refactor again from the last point where the tests passed. We can now apply the same to our other test method. \[code\] class CheckoutTests < Test::Unit::TestCase def new\_checkout prices = {'A':50, 'B':70} Checkout.new(prices) end def test\_scanning\_one\_a checkout = new\_checkout checkout.scan('A') assert\_equal(50, checkout.total) end def test\_scanning\_multiple\_items checkout = new\_checkout checkout.scan('A') checkout.scan('B') assert\_equal(120, checkout.total) end end \[/code\] **Extract to method using fields** Let's go back to our original test before we started refactoring. \[code\] class CheckoutTests < Test::Unit::TestCase def test\_scanning\_one\_a prices = {'A':50, 'B': 70} checkout = Checkout.new(prices) checkout.scan('A') assert\_equal(50, checkout.total) end def test\_scanning\_multiple\_items prices = {'A':50, 'B': 70} checkout = Checkout.new(prices) checkout.scan('A') checkout.scan('B') assert\_equal(120, checkout.total) end end \[/code\] This time we will try and break this down into steps in a different way. We'll start by assigning our checkout to a field. \[code\] def test\_scanning\_one\_a prices = {'A':50, 'B': 70} @checkout = Checkout.new(prices) @checkout.scan('A') assert\_equal(50, @checkout.total) end \[/code\] Now we'll move the setup into a different method called \[code\]setup\_checkout\[/code\]. \[code\] def setup\_checkout prices = {'A':50, 'B':70} @checkout = Checkout.new(prices) end def test\_scanning\_one\_a setup\_checkout @checkout.scan('A') assert\_equal(50, @checkout.total) end \[/code\] This has required less changes in our existing code so far. We can now use our \[code\]setup\_checkout\[/code\] method in our second test by simply assigning our checkout to a field again and then removing the first two lines. This would leave us with something like: \[code\] class CheckoutTests < Test::Unit::TestCase def setup\_checkout prices = {'A':50, 'B': 70} @checkout = Checkout.new(prices) end def test\_scanning\_one\_a setup\_checkout @checkout.scan('A') assert\_equal(50, @checkout.total) end def test\_scanning\_multiple\_items setup\_checkout @checkout.scan('A') @checkout.scan('B') assert\_equal(120, @checkout.total) end end \[/code\] In fact this works quite well as a test setup so we can rename our \[code\]setup\_checkout\[/code\] method to \[code\]setup\[/code\] and removing the calls to it so that it is run before each test by the test framework. This leaves us with: \[code\] class CheckoutTests < Test::Unit::TestCase def setup prices = {'A':50, 'B': 70} @checkout = Checkout.new(prices) end def test\_scanning\_one\_a @checkout.scan('A') assert\_equal(50, @checkout.total) end def test\_scanning\_multiple\_items @checkout.scan('A') @checkout.scan('B') assert\_equal(120, @checkout.total) end end \[/code\] **Summary** We've looked at two approaches to doing this refactoring. Firstly we extracted a method to return a new checkout. I would probably use this if I was wanting to abstract away something complicated or dirty that would hinder readability. The second approach where we used assigned our checkout to a field on the object and used that everywhere instead. In the example we used I would probably prefer this approach. We've moved the repeated algorithm (setting up the checkout) to state, which in this case I think is simpler and more readable. While this has been a very simple example, practicing refactorings in this situation means that we have more options in our toolkit when we are working on real code. Hopefully you can see how taking small steps allows us to evaluate why we have chosen to use particular refactorings and help you think using about different approaches.