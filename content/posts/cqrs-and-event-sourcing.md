---
title: 'CQRS and Event Sourcing'
date: Thu, 11 Sep 2014 12:09:49 +0000
draft: false
tags: []
---

CQRS and Event Sourcing are hot topics at the moment, but I've found there are relatively few easy to follow examples or explanations, especially ones which aren't tied to particular vendors or languages. The one thing I've read, which has talked in detail about the concepts, rather than how to implement them was [this](https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=5&cad=rja&uact=8&ved=0CEQQFjAE&url=http%3A%2F%2Fcqrs.files.wordpress.com%2F2010%2F11%2Fcqrs_documents.pdf&ei=wVUPVJSpJYyR7AbV94HoCQ&usg=AFQjCNF5hAyxWhEWakeJoUdw1ry4nmULUw&bvm=bv.74649129,d.ZGU) from Greg Young, which is definitely worth a read, even if it is rather long. While I'm not the most eloquent of writers, I thought I'd have a go at explaining some concepts as I've experienced them and try to show you that you don't need fancy event stores or to be writing "enterprise software" to benefit. In fact I think the main point I want to get across is that you don't have to use DDD (Domain Driven Design) to take advantage of CQRS or event sourcing. Maybe it would help to get the best results, but it is certainly not necessary. **So... What is CQRS?** CQRS stands for **C**ommand **Q**uery **R**esponsibility **S**egregation. Quite simply this means having objects which are commands and objects which are queries. The idea for this (I assume) comes from [Bertrand Meyer's Command Query Separation](http://en.wikipedia.org/wiki/Command%E2%80%93query_separation), where he suggests that each method should either be a command (something that changes the application's state) or a query (something that reads the application's state). Except now instead of methods mutating and querying state, it's objects. **Commands** Commands are exactly what they sound like, they tell your application to do something. Whatever is doing the commanding is like a manager, it doesn't care how it happens, just so long as it's done. A command should be handled by... well, a command handler (obviously), which should interact with your services (using DDD terminology, if you're not familiar with this then just think of the service as an object that interacts with other models to get them to do things). It should be noted at this point, that I think my practical understanding differs slightly from others. In most examples, commands are explicitly called commands. For me, commands don't have to be called MyCommand or implement ICommand. They just need to be quite obviously commanding your application to do something. If you code is complicated enough that you can't tell from a glance (for example, by not returning a value), then you are probably missing an abstraction somewhere or are trying to do too much in your command. **Hexagonal architecture** So I should probably have explained this first, but it seems to fit here too. I like to use hexagonal architecture for many of my projects. This is where you have a central "hexagon" which has all your application logic in it, and "adapters" attached to the "sides" or "ports" which talk to the outside world. The outside world could be a web service that allows other applications to interact with yours, a database or an API you're consuming. Basically anything that isn't just a plain-old-(insert your language of choice here)-object. This means you can unit test just the inside of your hexagon. As they are just plain-old-(insert your language of choice here)-objects, these tests should be quick and require relatively little setup. What's all this got to do with CQRS? The commands are how you control with innards of your hexagon. Rather than calling straight into it, you send a command into it. This gives you a nice separation of concerns, a simple abstract concept to work with from outside your hexagon and a simple API to adhere to and test from inside. **Queries** So you've probably guessed by now that queries are how we read the state of our application. Again I try to think of this as something outside the hexagon querying what is inside the hexagon. This could be someone sending a GET request your RESTful service, which in turn sends a query into the bowels of your hexagon to satisfy the request, or a user interface sending in a query to get information to display. **So why use CQRS?** For me the big advantage of CQRS (not taking into account the cumulative benefit you get from using CQRS with event sourcing), is simplicity. It may seem like a lot of over head but in a complex domain any extra simplicity is a blessing. Even in less complex domains, applications will become ([accidentally](http://en.wikipedia.org/wiki/No_Silver_Bullet)) more complex. People often cite performance as a benefit, as you can tune your read and writes, but there are other techniques you can use to monitor performance and I'd be very hesitant to recommend using CQRS solely for performance reasons. I've also heard of people refactoring to CQRS to try and increase performance. I'd suggest that there are probably bigger and easier gains to be had elsewhere, which can be highlighted through profiling. **Event Sourcing** I like to think of event sourcing simply as raising and recording global events, which other parts of the system can subscribe to to update the state of the application. Or in other words, each command raises an event, which is then persisted. Some subscriber to this event can then update the state of the application, ready for it to be queried. While there are out of the box event store solutions, they are generally so simple that I find it easier to write my own. It just requires some way of subscribing to events on, so that events can be dispatched to the correct subscriber. People tend to suggest using a NoSQL database, such as MongoDB, to persist events, but I've used both relational and NoSQL databases and never had any problems, even when receiving thousands of events per second. **Reporting and monitoring** One nice side effect I've found from using event sourcing is how easy it is to setup application level monitoring and generate reports. **What is application level monitoring?** Monitoring is used to keep an eye on things and make sure everything is operating correctly. Monitoring at the application level simply means monitoring that your business rules are executing as you expect. I like to think of this being a bit like testing your live production code in the live production environment. **Conclusion** I hope I've managed to get across that CQRS and event sourcing are not complicated topics. Like all architectural and design patterns they are simply useful tools, which, if you understand the basic concepts, can help you make your own decisions about how they could be used. My challenge to you is to write a small project (perhaps as a kata), which uses CQRS or event sourcing and see how it feels in comparison with how you normally work.