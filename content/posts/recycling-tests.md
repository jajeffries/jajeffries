---
title: 'Recycling tests'
date: Tue, 30 Jun 2015 20:28:23 +0000
draft: false
tags: []
---

A couple of people have asked me about recycling tests recently, so I thought I’d put down some thoughts and an example here. Recycling tests is where you reuse old tests rather than writing new ones. Seb Rose changes the first step of the TDD cycle to

> writing a failing test or make an existing test fail.

However, I don’t like the wording of this because to me it suggests that you could change the code to get a failing test. Instead I prefer

> writing a failing test or change an existing test to fail.

**An Example** As usual I’ll be using the checkout kata. I'll probably skim over a few details here, but hopefully you can still follow the changes I've made. Let’s imagine I’ve got my first test passing and I’ve refactored. \[code\] import unittest class Tests(unittest.TestCase): def test\_basic\_price(self): item\_price = 30 checkout = Checkout(item\_price) checkout.scan('A') self.assertEqual(30, checkout.total()) class Checkout(object): def \_\_init\_\_(self, item\_price): self.item\_price = item\_price self.current\_total = 0 def scan(self, item): self.current\_total = self.item\_price def total(self): return self.current\_total if \_\_name\_\_ == '\_\_main\_\_': unittest.main() \[/code\] Notice how our scan method at the moment just sets the current\_total, rather than adding to it. Our current test doesn’t specify this, so lets change our test to force us to add to our total. \[code\] class Tests(unittest.TestCase): def test\_basic\_price(self): item\_price = 30 checkout = Checkout(item\_price) checkout.scan('A') checkout.scan('A') self.assertEqual(60, checkout.total()) \[/code\] Now, we have a failing test again without writing a new test. We’ve just changed our existing test so haven’t added duplication (and all sorts of [connascence](http://silkandspinach.net/tag/connascence/)), but we still have the same test coverage. Let's make our test pass. \[code\] class Checkout(object): def \_\_init\_\_(self, item\_price): self.item\_price = item\_price self.current\_total = 0 def scan(self, item): self.current\_total += self.item\_price def total(self): return self.current\_total \[/code\] We can change our test for our next requirement too: scanning multiple types of item. \[code\] class Tests(unittest.TestCase): def test\_basic\_price(self): price\_of\_a = 30 price\_of\_b = 50 checkout = Checkout(price\_of\_a, price\_of\_b) checkout.scan('A') checkout.scan('B') self.assertEqual(price\_of\_a + price\_of\_b, checkout.total()) \[/code\] Again, we've not added any new tests, but have changed our old test to fail. Now for the code. \[code\] class Checkout(object): def \_\_init\_\_(self, price\_of\_a, price\_of\_b): self.price\_of\_a = price\_of\_a self.price\_of\_b = price\_of\_b self.current\_total = 0 def scan(self, item): if item == 'A': self.current\_total += self.price\_of\_a else: self.current\_total += self.price\_of\_b def total(self): return self.current\_total \[/code\] **Review** There are a definite advantages to recycling tests. In our example, we have significantly less tests and as a result much less duplication. However, I can also see a potential problem. It would be possible (especially in a more complicated example) for regressions to be introduced, which wouldn't be caught by our test safety net. To avoid this we can be more careful with how we change our tests to fail. For example, recall when we added the second item type in our previous example. Our test looked like this: \[code\] class Tests(unittest.TestCase): def test\_basic\_price(self): price\_of\_a = 30 price\_of\_b = 50 checkout = Checkout(price\_of\_a, price\_of\_b) checkout.scan('A') checkout.scan('B') self.assertEqual(price\_of\_a + price\_of\_b, checkout.total()) \[/code\] Instead of changing the second scan to scan a 'B', we could add scanning 'B' after scanning two 'A's. \[code\] class Tests(unittest.TestCase): def test\_basic\_price(self): price\_of\_a = 30 price\_of\_b = 50 checkout = Checkout(price\_of\_a, price\_of\_b) checkout.scan('A') checkout.scan('A') checkout.scan('B') self.assertEqual(price\_of\_a + price\_of\_a + price\_of\_b, checkout.total()) \[/code\] Now we have similar coverage as we would with two tests, but at the expense of a slightly more complicated test. I'd be interested to know if other people have come across this problem, or if they think I'm being over cautious. If you have any thoughts on any of this drop me a [tweet at @jjeffries1](https://twitter.com/jjeffries1) ;-)